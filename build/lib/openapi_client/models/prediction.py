# coding: utf-8

"""
    API Reference

    Robotoff provides a simple API allowing consumers to fetch predictions and annotate them.  All endpoints must be prefixed with `/api/v1`. The full URL is `https://robotoff.openfoodfacts.org/api/v1/{endpoint}`. 

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from decimal import Decimal
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Prediction(BaseModel):
    """
    a Robotoff Prediction
    """ # noqa: E501
    barcode: Optional[StrictStr] = Field(default=None, description="barcode of the product")
    type: Optional[StrictStr] = Field(default=None, description="the prediction type")
    timestamp: Optional[datetime] = Field(default=None, description="datetime of creation of the prediction")
    data: Optional[Dict[str, Any]] = Field(default=None, description="a JSON structure containing prediction data. It either complements `value` and `value_tag` with additional data or contains the full prediction data. ")
    value_tag: Optional[StrictStr] = Field(default=None, description="the value tag of the prediction. The use of this field depends of the prediction type, but it contains most of the time the canonical tag that should be sent to Product Opener. For example, for a category prediction, `value_tag` can be `en:beverages`. ")
    value: Optional[StrictStr] = Field(default=None, description="the value of the prediction. It is used if no canonical tag can be used for the prediction type. For example, we use it to store the detected product weight value (example: `100 g`) ")
    automatic_processing: Optional[StrictBool] = Field(default=None, description="a boolean indicating whether we're confident enough in the prediction to apply it automatically in Open Food Facts without human supervision. This does not mean it will indeed be applied automatically, please refer to the import mechanism description in the documentation to know how automatic processing works. ")
    source_image: Optional[StrictStr] = Field(default=None, description="the path of the image the prediction was generated from. May be null, it is mainly provided for OCR and object detection-based predictions. ")
    id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="unique ID of the prediction in the PostgreSQL DB")
    predictor_version: Optional[StrictStr] = Field(default=None, description="this is a version ID that is used to know when to replace predictions in database by new ones during import, and when to keep them. It is either an incrementing integer (for regex-based predictions) or the version of the model that generated the predictions. ")
    predictor: Optional[StrictStr] = Field(default=None, description="name of the predictor that generated the prediction. Every insight type has its own `predictor`s, but most common ones are:   - `universal-logo-detector` for predictions generated by the nearest-neighbors logo detector   - `flashtext` for all predictions generated using flashtext library   - `regex` for all predictions generated using simple regex ")
    server_type: Optional[StrictStr] = Field(default=None, description="The server type (=project) to use, such as 'off' (Open Food Facts), 'obf' (Open Beauty Facts),...")
    confidence: Optional[Decimal] = Field(default=None, description="confidence score of the prediction, it is only provided for ML-based predictions. It may be null. ")
    __properties: ClassVar[List[str]] = ["barcode", "type", "timestamp", "data", "value_tag", "value", "automatic_processing", "source_image", "id", "predictor_version", "predictor", "server_type", "confidence"]

    @field_validator('server_type')
    def server_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['off', 'obf', 'opff', 'opf', 'off_pro']):
            raise ValueError("must be one of enum values ('off', 'obf', 'opff', 'opf', 'off_pro')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Prediction from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Prediction from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "barcode": obj.get("barcode"),
            "type": obj.get("type"),
            "timestamp": obj.get("timestamp"),
            "data": obj.get("data"),
            "value_tag": obj.get("value_tag"),
            "value": obj.get("value"),
            "automatic_processing": obj.get("automatic_processing"),
            "source_image": obj.get("source_image"),
            "id": obj.get("id"),
            "predictor_version": obj.get("predictor_version"),
            "predictor": obj.get("predictor"),
            "server_type": obj.get("server_type"),
            "confidence": obj.get("confidence")
        })
        return _obj


